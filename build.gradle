/*
 * Copyright and related rights waived via CC0
 *
 * You should have received a copy of the CC0 legalcode along with this
 * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */
import groovy.json.JsonSlurper

import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

/*
 * Copyright and related rights waived via CC0
 *
 * You should have received a copy of the CC0 legalcode along with this
 * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */

plugins {
    id 'base'
    id "com.diffplug.spotless" version "6.3.0"
    id "org.graalvm.internal.tck-base"
}

allprojects {
    repositories {
        mavenCentral()
        mavenLocal()
    }
}

// NOTE: this version serves only as a placeholder and will be overridden by the CI when creating a new release
project.version("1.0.0-SNAPSHOT")

// gradle check
spotless {
    json {
        target(
                tck.metadataRoot.map { it.toString() + '/**/*.json' }.get(),
                tck.testRoot.map { it.toString() + '/**/*.json' }
        )
        targetExclude(
                tck.testRoot.map { it.toString() + '/**/build/**/*.json' },
                tck.repoRoot.map { it.toString() + '/.github/**/*.json' }
        )
        gson()
                .indentWithSpaces(2)
                .sortByKeys()
                .version("2.9.0")
    }
    java {
        target('**/*.java')
        targetExclude(
                'metadata/**', // only JSON there
                '**/build/**',
                'gradle/header.java')
        // Place header before package/import/module
        licenseHeaderFile("$rootDir/gradle/header.java", "package |import |module ")
    }

    String[] noHeaderDirs = [
            'docs/**',     // only .md files
            'metadata/**', // only .json files
            '**/build/**', // not relevant
            'gradle/wrapper/**', // not relevant
    ]
    groovy {
        target('**/*.groovy')
        targetExclude(noHeaderDirs)
        // Place header before package/import
        licenseHeaderFile("$rootDir/gradle/header.java", "package |import ")
    }
    groovyGradle {
        // Build scripts (*.gradle)
        target('**/*.gradle')
        targetExclude(noHeaderDirs)
        targetExclude('tests/**')
        // Insert header at file start (works for any Gradle script layout)
        licenseHeaderFile("$rootDir/gradle/header.java", "(?m)^(import\\b|plugins\\b|buildscript\\b|apply\\b|rootProject\\b|pluginManagement\\b|dependencyResolutionManagement\\b)")
    }
    format('shell') {
        target('**/*.sh')
        targetExclude(noHeaderDirs)
        // Ensure header appears after shebang if present, else at the very top.
        def shHeader = file("$rootDir/gradle/header.sh").text
        // If file starts with a shebang and is missing the header, insert it after the shebang
        replaceRegex('insert-license-after-shebang',
                     '(?s)\\A(#!.*\\n)(?!# Copyright and related rights waived via CC0\\n)',
                     '$1' + shHeader + "\n")
        // If file has no shebang and is missing the header, insert it at the start
        replaceRegex('insert-license-at-start',
                     '(?s)\\A(?!#!)(?!# Copyright and related rights waived via CC0\\n)',
                     shHeader + "\n")
    }
}

// gradle package
tasks.register('package', Zip) { task ->
    String outputFileName = "graalvm-reachability-metadata-${project.version}.zip"
    task.setDescription("Packages current repository to 'build/${outputFileName}'")
    task.setGroup(PublishingPlugin.PUBLISH_TASK_GROUP)
    task.archiveFileName = outputFileName
    task.destinationDirectory = layout.buildDirectory

    from(tck.metadataRoot)
    // library-and-framework-list.json is used by Native Build Tools to provide additional
    // information on library and framework support to the native image Build Report
    from(project.rootDir) {
        include("library-and-framework-list.json")
    }
}

tasks.register('test') { t ->
    t.setDescription("Aggregates tests configured by the TCK harness")
    t.setGroup("verification")
}

// Apply the harness after creating the 'test' aggregator to avoid missing property,
// and without applying the 'java' plugin to avoid task name conflicts.
apply plugin: "org.graalvm.internal.tck-harness"

ext.runLoggedCommand = { List<String> args, String label, File logFile, File workingDir ->
    def header = "==== BEGIN ${label}"
    println(header)
    logFile.text = header + System.lineSeparator()

    def pb = new ProcessBuilder(args as String[])
    pb.directory(workingDir)
    pb.redirectErrorStream(true)
    pb.redirectOutput(ProcessBuilder.Redirect.appendTo(logFile))
    def proc = pb.start()
    int exit = proc.waitFor()

    def footer = exit != 0
            ? "==== END ${label} FAILURE (exit ${exit})"
            : "==== END ${label} SUCCESS"
    logFile.append(footer + System.lineSeparator())
    println(footer)
    return exit
}

static List<Map> testAllCommands(String gradleCmd, String target) {
    def taskNames = [
            "checkstyle",
            "spotlessCheck",
            "checkMetadataFiles",
            "fetchExistingLibrariesWithNewerVersions",
            "test"
    ]
    return taskNames.collect { name ->
        [name: name, args: [gradleCmd, name, "-Pcoordinates=${target}"]]
    }
}

/*
 * Helper utilities for environment setup, and backup/restore
 * used by testMetadataGeneration.
 */
def withUnsetTckDir(List<String> baseArgs) {
    if (System.getProperty("os.name").toLowerCase().contains("windows")) {
        ["cmd.exe", "/d", "/c", "set GVM_TCK_TCKDIR= && " + baseArgs.join(' ')]
    } else {
        ["/usr/bin/env", "-u", "GVM_TCK_TCKDIR"] + baseArgs
    }
}

def backupDirIfExists(File srcDir, File backupDir) {
    boolean had = srcDir?.isDirectory()
    if (had) {
        backupDir.parentFile?.mkdirs()
        project.copy {
            from(srcDir)
            into(backupDir)
        }
    }
    had
}

def restoreDir(boolean had, File srcDir, File backupDir) {
    if (had) {
        project.delete(srcDir)
        srcDir.mkdirs()
        project.copy {
            from(backupDir)
            into(srcDir)
        }
    } else {
        project.delete(srcDir)
    }
}
def backupFileIfExists(File srcFile, File backupFile) {
    boolean had = srcFile?.isFile()
    if (had) {
        backupFile.parentFile?.mkdirs()
        backupFile.text = srcFile.getText('UTF-8')
    }
    had
}
def restoreFileIfBackedUp(boolean had, File srcFile, File backupFile) {
    if (had && backupFile?.isFile()) {
        srcFile.text = backupFile.getText('UTF-8')
    }
}

// Test metadata generation tasks
def testMetadataGeneration(String coordinate, String gradleCmd, File logsDir, String newVersion) {

    def fileSuffix = coordinate.replaceAll(File.separator, "-")

    // Compute paths and snapshot current state to allow revert after the test
    def parts = coordinate.split(":")
    if (parts.length != 3) {
        throw new GradleException("Invalid coordinates '${coordinate}'. Expected 'group:artifact:version'.")
    }
    def group = parts[0]
    def artifact = parts[1]
    def version = parts[2]
    def gaPath = "${group}/${artifact}"
    def versionPath = "${gaPath}/${version}"

    def versionDir = new File(tck.metadataRoot.get().asFile, versionPath)
    def testsDir = new File(tck.testRoot.get().asFile, versionPath)

    def backupRoot = layout.buildDirectory.dir("gm-backups/${fileSuffix}").get().asFile
    def backupMetadataDir = new File(backupRoot, "metadata-backup")
    def backupTestsDir = new File(backupRoot, "tests-backup")
    backupRoot.mkdirs()
    boolean hadVersionDir = backupDirIfExists(versionDir, backupMetadataDir)
    boolean hadTestsDir = backupDirIfExists(testsDir, backupTestsDir)

    try {
        // Build base args once, then prepend an OS-specific unset of GVM_TCK_TCKDIR
        def baseGenArgs = [gradleCmd, "generateMetadata", "-Pcoordinates=${coordinate}", "--agentAllowedPackages=org.postgresql"]
        List<String> genArgs = withUnsetTckDir(baseGenArgs)
        def genLogFile = new File(logsDir, "generateMetadata-${fileSuffix}.log")
        int genExit = project.ext.runLoggedCommand(genArgs, "generateMetadata (${coordinate})", genLogFile, project.rootDir)
        if (genExit != 0) {
            throw new GradleException("generateMetadata failed with exit code ${genExit} (see ${genLogFile})")
        }

        // Verify output directory for the specific version
        if (!versionDir.isDirectory()) {
            throw new GradleException("Version directory not found: ${versionDir}")
        }

        def actualFiles = versionDir.listFiles()?.findAll { it.isFile() }?.collect { it.name }?.sort() ?: []
        if (actualFiles.isEmpty()) {
            throw new GradleException("No metadata files found in ${versionDir}")
        }

        println("Verified generated metadata for ${coordinate}: ${versionDir}")
    } finally {
        // Revert metadata directory changes
        restoreDir(hadVersionDir, versionDir, backupMetadataDir)
        // Revert tests directory changes (including build.gradle and user-code-filter.json)
        restoreDir(hadTestsDir, testsDir, backupTestsDir)
        // Cleanup backups
        project.delete(backupRoot)
    }


    def newVersionDir = new File(tck.metadataRoot.get().asFile, "${gaPath}/${newVersion}")

    def moduleIndexFile = new File(tck.metadataRoot.get().asFile, "${gaPath}/index.json")

    def fixBackupRoot = layout.buildDirectory.dir("fixnir-backups/${fileSuffix}").get().asFile
    def backupNewMetadataDir = new File(fixBackupRoot, "new-metadata-backup")
    def fixBackupTestsDir = new File(fixBackupRoot, "new-metadata-backup")
    def backupModuleIndexFile = new File(fixBackupRoot, "module-index.json.bak")
    fixBackupRoot.mkdirs()
    hadTestsDir = backupDirIfExists(testsDir, fixBackupTestsDir)
    def hadNewVersionDir = backupDirIfExists(newVersionDir, backupNewMetadataDir)
    def hadModuleIndexFile = backupFileIfExists(moduleIndexFile, backupModuleIndexFile)

    try {
        def baseFixArgs = [gradleCmd, "fixTestNativeImageRun", "-PtestLibraryCoordinates=${coordinate}", "-PnewLibraryVersion=${newVersion}"]
        List<String> fixArgs = withUnsetTckDir(baseFixArgs)
        def fixLogFile = new File(logsDir, "fixTestNativeImageRun-${fileSuffix}.log")
        int fixExit = project.ext.runLoggedCommand(fixArgs, "fixTestNativeImageRun (${coordinate} -> ${newVersion})", fixLogFile, project.rootDir)
        if (fixExit != 0) {
            throw new GradleException("fixTestNativeImageRun failed with exit code ${fixExit} (see ${fixLogFile})")
        }
    } finally {
        // Revert changes
        restoreDir(hadNewVersionDir, newVersionDir, backupNewMetadataDir)
        restoreDir(hadTestsDir, testsDir, fixBackupTestsDir)
        restoreFileIfBackedUp(hadModuleIndexFile, moduleIndexFile, backupModuleIndexFile)
        // Cleanup backups
        project.delete(fixBackupRoot)
    }
}

tasks.register('testAllParallel') { t ->
    t.group = "verification"
    t.setDescription("For each target, run clean and pullAllowedDockerImages first (sequentially), then run style checks and individual testing stages (${testAllCommands('', '').collect { it.name }.join(', ')}) concurrently with isolated logs. Options: -Pcoordinates to specify a single coordinate or 1/64 for the pull step; -Pparallelism to control the number of concurrent tasks.")

    doLast {
        def selectedArtifact = "org.postgresql:postgresql:42.7.3"
        def selectedBatch = "1/64"

        def gradleCmd = System.getProperty("os.name").toLowerCase().contains("windows") ? "gradlew.bat" : "./gradlew"
        def parallelismProp = (project.findProperty('parallelism') ?: '').toString().trim()
        int parallelism = 4
        if (!parallelismProp.isEmpty()) {
            try {
                parallelism = Integer.parseInt(parallelismProp)
            } catch (NumberFormatException ignored) {
                throw new GradleException("Invalid -Pparallelism='${parallelismProp}': must be a positive integer.")
            }
            if (parallelism <= 0) {
                throw new GradleException("Invalid -Pparallelism='${parallelismProp}': must be >= 1.")
            }
        }
        println("Using parallelism=${parallelism} for testAllParallel.")

        def logsDir = layout.buildDirectory.dir("command-logs").get().asFile
        logsDir.mkdirs()

        // Helper to run pull + command set for a given target (artifact or coordinates)
        def runPhaseForCoordinate = { String coordinate ->
            // Clean project before pulling Docker images for this coordinate
            def cleanLogsDir = new File(project.rootDir, "command-logs-clean")
            cleanLogsDir.mkdirs()

            def fileSuffix = coordinate.replaceAll(File.separator, "-")
            def cleanLogFile = new File(cleanLogsDir, "clean-${fileSuffix}.log")
            int cleanExit = project.ext.runLoggedCommand([gradleCmd, "clean", "-Pcoordinates=${coordinate}"], "clean (${coordinate})", cleanLogFile, project.rootDir)
            if (cleanExit != 0) {
                throw new GradleException("clean failed with exit code ${cleanExit} (see ${cleanLogFile})")
            }
            // Ensure logsDir exists after clean
            logsDir.mkdirs()

            // Pull Docker images sequentially for this coordinate
            def pullArgs = [gradleCmd, "pullAllowedDockerImages", "-Pcoordinates=${coordinate}"]
            def pullLogFile = new File(logsDir, "pullAllowedDockerImages-${fileSuffix}.log")
            int pullExit = project.ext.runLoggedCommand(pullArgs, "pullAllowedDockerImages (${coordinate})", pullLogFile, project.rootDir)
            if (pullExit != 0) {
                throw new GradleException("pullAllowedDockerImages failed with exit code ${pullExit} (see ${pullLogFile})")
            }

            def commands = testAllCommands(gradleCmd, coordinate)
            int effectiveParallelism = Math.min(parallelism, commands.size())
            def pool = Executors.newFixedThreadPool(effectiveParallelism)
            def failures = Collections.synchronizedList(new ArrayList<Map>())
            def futures = []

            commands.each { cmd ->
                futures << pool.submit {
                    def label = "${cmd.name} (${coordinate})"
                    def logFile = new File(logsDir, "${cmd.name}-${fileSuffix}.log")
                    int exit = project.ext.runLoggedCommand(cmd.args, label, logFile, project.rootDir)
                    if (exit != 0) {
                        failures.add([label: label, logFile: logFile, exit: exit])
                    }
                }
            }

            futures.each { it.get() }
            pool.shutdown()
            pool.awaitTermination(1, TimeUnit.HOURS)

            if (!failures.isEmpty()) {
                println("Some commands failed (coordinates=${coordinate}). Logs in: ${logsDir}")
                failures.each { f ->
                    println(" - ${f.label} failed with exit code ${f.exit} (see ${f.logFile})")
                }
                println("==== BEGIN FAILED TASK LOGS (${coordinate})")
                failures.each { f ->
                    println("---- LOG: ${f.logFile}")
                    try {
                        if (f.logFile?.exists()) {
                            f.logFile.eachLine { println(it) }
                        } else {
                            println("(log file not found)")
                        }
                    } catch (Throwable e) {
                        println("Error reading ${f.logFile}: ${e.message}")
                    }
                }
                println("==== END FAILED TASK LOGS (${coordinate})")
                throw new GradleException("Failures encountered. See logs above. Logs directory: ${logsDir}")
            } else {
                println("All commands succeeded for coordinates=${coordinate}. Logs in: ${logsDir}")
            }
        }
        def newVersionForFix = "42.7.4"

        // Run parallel phases sequentially: first the selectedArtifact, then the selectedBatch
        runPhaseForCoordinate(selectedArtifact)
        testMetadataGeneration(selectedArtifact, gradleCmd, logsDir, newVersionForFix)
        runPhaseForCoordinate(selectedBatch)
    }
}
