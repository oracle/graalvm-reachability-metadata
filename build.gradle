/*
 * Copyright and related rights waived via CC0
 *
 * You should have received a copy of the CC0 legalcode along with this
 * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */
import groovy.json.JsonSlurper

import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import groovy.json.JsonSlurper

plugins {
    id 'base'
    id "com.diffplug.spotless" version "6.3.0"
    id "org.graalvm.internal.tck-base"
}

allprojects {
    repositories {
        mavenCentral()
        mavenLocal()
    }
}

// NOTE: this version serves only as a placeholder and will be overridden by the CI when creating a new release
project.version("1.0.0-SNAPSHOT")

// gradle check
spotless {
    json {
        target(
                tck.metadataRoot.map { it.toString() + '/**/*.json' }.get(),
                tck.testRoot.map { it.toString() + '/**/*.json' }.get()
        )
        targetExclude(
                tck.testRoot.map { it.toString() + '/**/build/**/*.json' }.get(),
                tck.repoRoot.map { it.toString() + '/.github/**/*.json' }.get()
        )
        gson()
                .indentWithSpaces(2)
                .sortByKeys()
                .version("2.9.0")
    }
    String[] noHeaderDirs = [
            'native-build-tools/**', // external repository
            'docs/**',     // only .md files
            'metadata/**', // only .json files
            '**/build/**', // not relevant
            '**/.gradle/**', // not relevant
            'gradle/wrapper/**', // not relevant
            'tests/src/**/generated/**/*.java',
            'gradle/header.java',
            'gradle/header.sh',
    ]

    java {
        target('**/*.java')
        targetExclude(*noHeaderDirs);
        // Place header before package/import/module
        licenseHeaderFile("$rootDir/gradle/header.java", "package |import |module ")
    }

    groovy {
        target('**/*.groovy')
        targetExclude(*noHeaderDirs)
        // Place header before package/import
        licenseHeaderFile("$rootDir/gradle/header.java", "package |import ")
    }
    groovyGradle {
        // Build scripts (*.gradle)
        target('**/*.gradle')
        targetExclude(*noHeaderDirs)
        // Insert header at file start (works for any Gradle script layout)
        licenseHeaderFile("$rootDir/gradle/header.java", "(?m)^(import\\b|plugins\\b|buildscript\\b|apply\\b|rootProject\\b|pluginManagement\\b|dependencyResolutionManagement\\b)")
    }
    format('shell') {
        target('**/*.sh')
        targetExclude(*noHeaderDirs)
        // Ensure header appears after shebang if present, else at the very top.
        def shHeader = file("$rootDir/gradle/header.sh").text
        // If file starts with a shebang and is missing the header, insert it after the shebang
        replaceRegex('insert-license-after-shebang',
                     '(?s)\\A(#![^\\n]*\\n)(?:[ \\t]*\\n)*(?!# Copyright and related rights waived via CC0\\n)',
                     '$1' + shHeader + "\n")
        // If file has no shebang and is missing the header, insert it at the start
        replaceRegex('insert-license-at-start',
                     '(?s)\\A(?!#!)(?!# Copyright and related rights waived via CC0\\n)',
                     shHeader + "\n")
    }
}

// gradle package
tasks.register('package', Zip) { task ->
    String outputFileName = "graalvm-reachability-metadata-${project.version}.zip"
    task.setDescription("Packages current repository to 'build/${outputFileName}'")
    task.setGroup(PublishingPlugin.PUBLISH_TASK_GROUP)
    task.archiveFileName = outputFileName
    task.destinationDirectory = layout.buildDirectory

    from(tck.metadataRoot)
}

tasks.register('test') { t ->
    t.setDescription("Aggregates tests configured by the TCK harness")
    t.setGroup("verification")
}

// Apply the harness after creating the 'test' aggregator to avoid missing property,
// and without applying the 'java' plugin to avoid task name conflicts.
apply plugin: "org.graalvm.internal.tck-harness"

static List<Map> testInfraCommands(String gradleCmd, String target) {
    def taskNames = [
            "validateIndexFiles",
            "checkstyle",
            "spotlessCheck",
            "checkMetadataFiles",
            "fetchExistingLibrariesWithNewerVersions",
            "test",
    ]
    return taskNames.collect { name ->
        [name: name, args: [gradleCmd, name, "-Pcoordinates=${target}"]]
    }
}

tasks.register('testInfra') { t ->
    t.group = "verification"
    t.setDescription("""Runs clean and pullAllowedDockerImages, then runs (${testInfraCommands('', '').collect { it.name }.join(', ')}) concurrently with isolated logs for a single coordinate.
                        Options: -Pcoordinate or -Pcoordinates to specify the target; -Pparallelism to control the number of concurrent tasks.""")

    doLast {
        def coordinateProp = ((project.findProperty('coordinate') ?: project.findProperty('coordinates')) ?: '').toString().trim()
        if (coordinateProp.isEmpty()) {
            throw new GradleException("Missing -Pcoordinate=<group:artifact:version|k/n|all> (or -Pcoordinates).")
        }

        def gradleCmd = System.getProperty("os.name").toLowerCase().contains("windows") ? "gradlew.bat" : "./gradlew"
        int parallelism = parsePositiveIntProp('parallelism', 4)
        println("Using parallelism=${parallelism} for testInfra.")

        def logsDir = layout.buildDirectory.dir("command-logs").get().asFile
        logsDir.mkdirs()

        // Helper to run pull + command set for a given target (artifact or coordinates)
        def runPhaseForCoordinate = { String coordinate ->
            // Clean project before pulling Docker images for this coordinate
            // Note: 'clean' deletes the build/ directory, so log to a temporary location outside build/,
            // then move/copy the log into build/ afterwards.
            def tmpCleanLogsDir = new File(project.rootDir, ".tmp-command-logs-clean")
            tmpCleanLogsDir.mkdirs()
            def fileSuffix = sanitizeFileName(coordinate)
            def tmpCleanLogFile = new File(tmpCleanLogsDir, "clean-${fileSuffix}.log")
            try {
                runGradleTaskAndCheck(
                        [gradleCmd, "clean", "-Pcoordinates=${coordinate}"],
                        "clean (${coordinate})",
                        tmpCleanLogFile
                )
            } finally {
                // After clean, move/copy the log into the build folder (clean wipes build/)
                def cleanLogsDir = layout.buildDirectory.dir("command-logs-clean").get().asFile
                cleanLogsDir.mkdirs()
                def cleanLogFile = new File(cleanLogsDir, "clean-${fileSuffix}.log")
                try {
                    Files.move(tmpCleanLogFile.toPath(), cleanLogFile.toPath(), StandardCopyOption.REPLACE_EXISTING)
                } catch (Throwable ignored) {
                    if (tmpCleanLogFile?.exists()) {
                        cleanLogFile.text = tmpCleanLogFile.text
                    }
                }
            }
            // Ensure logsDir exists after clean
            logsDir.mkdirs()

            // Pull Docker images sequentially for this coordinate
            def pullArgs = [gradleCmd, "pullAllowedDockerImages", "-Pcoordinates=${coordinate}"]
            def pullLogFile = new File(logsDir, "pullAllowedDockerImages-${fileSuffix}.log")
            runGradleTaskAndCheck(pullArgs, "pullAllowedDockerImages (${coordinate})", pullLogFile)

            def commands = testInfraCommands(gradleCmd, coordinate)
            int effectiveParallelism = Math.min(parallelism, commands.size())
            def pool = Executors.newFixedThreadPool(effectiveParallelism)

            runCommandsWithPool(pool, coordinate, commands)
        }

        runPhaseForCoordinate(coordinateProp)
    }
}

tasks.register('testAllInfra') { t ->
    t.group = "verification"
    t.setDescription("Determines one artifact coordinate via generateInfrastructureChangedCoordinatesMatrix (or uses -Pcoordinate/-Pcoordinates if provided), then runs testInfra for that coordinate and also for 1/64. Options: -Pparallelism to control concurrency.")
    doLast {
        def gradleCmd = System.getProperty("os.name").toLowerCase().contains("windows") ? "gradlew.bat" : "./gradlew"
        int parallelism = parsePositiveIntProp('parallelism', 4)
        println("Using parallelism=${parallelism} for testAllInfra.")

        String artifactCoordinate = ((project.findProperty('coordinate') ?: project.findProperty('coordinates')) ?: '').toString().trim()
        if (artifactCoordinate.isEmpty()) {
            def matrixLogsDir = layout.buildDirectory.dir("command-logs").get().asFile
            matrixLogsDir.mkdirs()
            def matrixLog = runGenerateMatrixAndCheck(gradleCmd, matrixLogsDir)
            try {
                def line = matrixLog.readLines().find { it.startsWith("matrix=") }
                if (line != null) {
                    def jsonStr = line.substring("matrix=".length())
                    def parsed = new JsonSlurper().parseText(jsonStr)
                    def coords = (parsed["coordinates"] as List) ?: []
                    if (!coords.isEmpty()) {
                        artifactCoordinate = coords[0].toString()
                    }
                }
            } catch (Throwable e) {
                throw new GradleException("Failed to parse matrix output from ${matrixLog}: ${e.message}")
            }
            if (!artifactCoordinate) {
                throw new GradleException("No coordinates found in generateInfrastructureChangedCoordinatesMatrix output. Provide -Pcoordinate or -Pcoordinates to override.")
            }
        }
        println("Selected artifact coordinate: ${artifactCoordinate}")

        def logsDir = layout.buildDirectory.dir("command-logs").get().asFile
        logsDir.mkdirs()

        def runTestInfraAndCheck = { String coordinate, String gradleCmdParam, int parallelismParam, File logsDirParam, def layoutParam ->
            def logFile = new File(logsDirParam, "testInfra-${sanitizeFileName(coordinate)}.log")
            runGradleTaskAndCheck(
                [gradleCmdParam, "testInfra", "-Pcoordinate=${coordinate}", "-Pparallelism=${parallelismParam}"],
                "testInfra (${coordinate})",
                logFile
            )
        }

        runTestInfraAndCheck(artifactCoordinate, gradleCmd, parallelism, logsDir, layout)
        def batchCoordinate = "1/64"
        runTestInfraAndCheck(batchCoordinate, gradleCmd, parallelism, logsDir, layout)

        println("testAllInfra completed successfully.")
    }
}

/**
 * Runs a Gradle task with logging and throws GradleException on non-zero exit.
 *
 * @param args     Full command (gradle executable plus task and its arguments)
 * @param label    Human-readable label used in logs
 * @param logFile  Destination log file
 * @return         The exit code of the process (also throws on non-zero)
 */
def runGradleTaskAndCheck(List<String> args, String label, File logFile) {
    int exit = runLoggedCommand(args, label, logFile, project.rootDir)
    if (exit != 0) {
        throw new GradleException("${label} failed with exit code ${exit} (see ${logFile})")
    }
    return exit
}

/**
 * Runs generateInfrastructureChangedCoordinatesMatrix and returns the log file.
 *
 * @param gradleCmd   Gradle executable path (e.g., "./gradlew" or "gradlew.bat")
 * @param logsDir     Directory where the log will be written
 * @return            The File pointing to the generated matrix log
 */
def runGenerateMatrixAndCheck(String gradleCmd, File logsDir) {
    logsDir.mkdirs()
    def logFile = new File(logsDir, "generateInfrastructureChangedCoordinatesMatrix.log")
    runGradleTaskAndCheck(
        [gradleCmd, "generateInfrastructureChangedCoordinatesMatrix"],
        "generateInfrastructureChangedCoordinatesMatrix",
        logFile
    )
    return logFile
}

/**
 * Executes an external command, logs its output to both the console and a dedicated file,
 * and returns the exit code. Prepends and appends custom headers and footers to the log
 * indicating success or failure.
 *
 * Behavior:
 * - Prints a header to both console and log file before running the command.
 * - Ensures parent directories for the log file exist, and overwrites the file with the header.
 * - Runs the provided command in a specified working directory, logging both stdout and stderr to the file.
 * - Waits for the process to finish and captures its exit code.
 * - Appends a footer line to both console and log to indicate SUCCESS or FAILURE, including the exit code if failed.
 * - Returns the process exit code to the caller.
 *
 * @param args      The command as a list of strings (executable plus arguments).
 * @param label     A label for this invocation, included in the header/footer.
 * @param logFile   File to which all output is logged (will be created/overwritten).
 * @param workingDir Directory in which to execute the process.
 * @return          The exit code of the process.
 */
def runLoggedCommand(List<String> args, String label, File logFile, File workingDir) {
    def startTime = new Date().format("yyyy-MM-dd HH:mm:ss")
    def header = "==== [${startTime}] BEGIN ${label} logged at ${logFile.absolutePath}"
    println(header)
    if (logFile?.parentFile) {
        logFile.parentFile.mkdirs()
    }
    logFile.text = header + System.lineSeparator()

    def pb = new ProcessBuilder(args as String[])
    pb.directory(workingDir)
    pb.redirectErrorStream(true)
    pb.redirectOutput(ProcessBuilder.Redirect.appendTo(logFile))
    def proc = pb.start()
    int exit = proc.waitFor()

    def endTime = new Date().format("yyyy-MM-dd HH:mm:ss")
    def footer = exit != 0
            ? "==== [${endTime}] END   ${label} FAILURE (exit ${exit}) logged at ${logFile.absolutePath}"
            : "==== [${endTime}] END   ${label} SUCCESS logged at ${logFile.absolutePath}"

    if (exit != 0) {
        println("Failure log for ${label}")
        try {
            if (logFile?.exists()) {
                logFile.eachLine { println(it) }
            } else {
                println("(log file not found)")
            }
        } catch (Throwable e) {
            println("Error reading ${logFile}: ${e.message}")
        }
    }

    logFile.append(footer + System.lineSeparator())
    println(footer)
    return exit
}

/**
 * Runs a set of external commands concurrently using the provided ExecutorService, writing
 * per-command logs under build/command-logs and aggregating failures.
 *
 * Behavior:
 * - Submits each command to the pool via submit(Callable) and waits for all futures to complete.
 * - Shuts down the pool and awaits termination for up to 1 hour.
 * - On any non-zero exit, prints a summary and the contents of the failed logs, then throws a GradleException.
 * - On success, prints a summary message indicating the logs directory.
 *
 * @param coordinate A label used for log file names and messages (e.g., an artifact coordinate or a batch like 1/64).
 * @param commands   List of maps representing commands to run; each entry must contain:
 *                   - name: String task label (e.g., "checkstyle")
 *                   - args: List<String> full process arguments passed to ProcessBuilder
 * @param pool       ExecutorService used to run the commands concurrently; this method will call
 *                   shutdown() and awaitTermination(...) on it.
 * @throws GradleException if any command exits with a non-zero status.
 */
def runCommandsWithPool(ExecutorService pool, String coordinate, List<Map> commands) {
    def logsDir = layout.buildDirectory.dir("command-logs").get().asFile
    logsDir.mkdirs()
    def fileSuffix = sanitizeFileName(coordinate)
    def failures = Collections.synchronizedList(new ArrayList<Map>())
    def futures = []

    commands.each { cmd ->
        futures << pool.submit {
            def label = "${cmd.name} (${coordinate})"
            def logFile = new File(logsDir, "${cmd.name}-${fileSuffix}.log")
            int exit = runLoggedCommand(cmd.args, label, logFile, project.rootDir)
            if (exit != 0) {
                failures.add([label: label, logFile: logFile, exit: exit])
            }
        }
    }

    futures.each { it.get() }
    pool.shutdown()
    pool.awaitTermination(1, TimeUnit.HOURS)

    if (!failures.isEmpty()) {
        println("Some commands failed (coordinates=${coordinate}). Logs in: ${logsDir}")
        failures.each { f ->
            println(" - ${f.label} failed with exit code ${f.exit} (see ${f.logFile})")
        }
        println("==== BEGIN FAILED TASK LOGS (${coordinate})")
        failures.each { f ->
            println("---- LOG: ${f.logFile}")
            try {
                if (f.logFile?.exists()) {
                    f.logFile.eachLine { println(it) }
                } else {
                    println("(log file not found)")
                }
            } catch (Throwable e) {
                println("Error reading ${f.logFile}: ${e.message}")
            }
        }
        println("==== END FAILED TASK LOGS (${coordinate})")
        throw new GradleException("Failures encountered. See logs above. Logs directory: ${logsDir}")
    } else {
        println("All commands succeeded for coordinates=${coordinate}. Logs in: ${logsDir}")
    }
}

/**
 * Parses a project property as a positive integer, returning defaultValue if empty.
 * Throws GradleException for invalid or non-positive values.
 */
def parsePositiveIntProp(String propertyName, int defaultValue) {
    def prop = (project.findProperty(propertyName) ?: '').toString().trim()
    int value = defaultValue
    if (!prop.isEmpty()) {
        try {
            value = Integer.parseInt(prop)
        } catch (NumberFormatException ignored) {
            throw new GradleException("Invalid -P${propertyName}='${prop}': must be a positive integer.")
        }
        if (value <= 0) {
            throw new GradleException("Invalid -P${propertyName}='${prop}': must be >= 1.")
        }
    }
    return value
}

/*
 * Helper utilities for environment setup, and backup/restore
 * used by testMetadataGeneration.
 */
def withUnsetTckDir(List<String> baseArgs) {
    if (System.getProperty("os.name").toLowerCase().contains("windows")) {
        ["cmd.exe", "/d", "/c", "set GVM_TCK_TCKDIR= && " + baseArgs.join(' ')]
    } else {
        ["/usr/bin/env", "-u", "GVM_TCK_TCKDIR"] + baseArgs
    }
}

def backupDirIfExists(File srcDir, File backupDir) {
    boolean had = srcDir?.isDirectory()
    if (had) {
        backupDir.parentFile?.mkdirs()
        project.copy {
            from(srcDir)
            into(backupDir)
        }
    }
    had
}

def restoreDir(boolean had, File srcDir, File backupDir) {
    if (had) {
        project.delete(srcDir)
        srcDir.mkdirs()
        project.copy {
            from(backupDir)
            into(srcDir)
        }
    } else {
        project.delete(srcDir)
    }
}
def backupFileIfExists(File srcFile, File backupFile) {
    boolean had = srcFile?.isFile()
    if (had) {
        backupFile.parentFile?.mkdirs()
        backupFile.text = srcFile.getText('UTF-8')
    }
    had
}
def restoreFileIfBackedUp(boolean had, File srcFile, File backupFile) {
    if (had && backupFile?.isFile()) {
        srcFile.text = backupFile.getText('UTF-8')
    }
}

// Test metadata generation tasks
def testMetadataGeneration(String coordinate, String gradleCmd, File logsDir, String newVersion) {

    def fileSuffix = coordinate.replaceAll(File.separator, "-")

    // Compute paths and snapshot current state to allow revert after the test
    def parts = coordinate.split(":")
    if (parts.length != 3) {
        throw new GradleException("Invalid coordinates '${coordinate}'. Expected 'group:artifact:version'.")
    }
    def group = parts[0]
    def artifact = parts[1]
    def version = parts[2]
    def gaPath = "${group}/${artifact}"
    def versionPath = "${gaPath}/${version}"

    def versionDir = new File(tck.metadataRoot.get().asFile, versionPath)
    def testsDir = new File(tck.testRoot.get().asFile, versionPath)

    def backupRoot = layout.buildDirectory.dir("gm-backups/${fileSuffix}").get().asFile
    def backupMetadataDir = new File(backupRoot, "metadata-backup")
    def backupTestsDir = new File(backupRoot, "tests-backup")
    backupRoot.mkdirs()
    boolean hadVersionDir = backupDirIfExists(versionDir, backupMetadataDir)
    boolean hadTestsDir = backupDirIfExists(testsDir, backupTestsDir)

    try {
        // Build base args once, then prepend an OS-specific unset of GVM_TCK_TCKDIR
        def baseGenArgs = [gradleCmd, "generateMetadata", "-Pcoordinates=${coordinate}", "--agentAllowedPackages=org.postgresql"]
        List<String> genArgs = withUnsetTckDir(baseGenArgs)
        def genLogFile = new File(logsDir, "generateMetadata-${fileSuffix}.log")
        int genExit = project.ext.runLoggedCommand(genArgs, "generateMetadata (${coordinate})", genLogFile, project.rootDir)
        if (genExit != 0) {
            throw new GradleException("generateMetadata failed with exit code ${genExit} (see ${genLogFile})")
        }

        // Verify output directory for the specific version
        if (!versionDir.isDirectory()) {
            throw new GradleException("Version directory not found: ${versionDir}")
        }

        def actualFiles = versionDir.listFiles()?.findAll { it.isFile() }?.collect { it.name }?.sort() ?: []
        if (actualFiles.isEmpty()) {
            throw new GradleException("No metadata files found in ${versionDir}")
        }

        println("Verified generated metadata for ${coordinate}: ${versionDir}")
    } finally {
        // Revert metadata directory changes
        restoreDir(hadVersionDir, versionDir, backupMetadataDir)
        // Revert tests directory changes (including build.gradle and user-code-filter.json)
        restoreDir(hadTestsDir, testsDir, backupTestsDir)
        // Cleanup backups
        project.delete(backupRoot)
    }


    def newVersionDir = new File(tck.metadataRoot.get().asFile, "${gaPath}/${newVersion}")

    def moduleIndexFile = new File(tck.metadataRoot.get().asFile, "${gaPath}/index.json")

    def fixBackupRoot = layout.buildDirectory.dir("fixnir-backups/${fileSuffix}").get().asFile
    def backupNewMetadataDir = new File(fixBackupRoot, "new-metadata-backup")
    def fixBackupTestsDir = new File(fixBackupRoot, "new-metadata-backup")
    def backupModuleIndexFile = new File(fixBackupRoot, "module-index.json.bak")
    fixBackupRoot.mkdirs()
    hadTestsDir = backupDirIfExists(testsDir, fixBackupTestsDir)
    def hadNewVersionDir = backupDirIfExists(newVersionDir, backupNewMetadataDir)
    def hadModuleIndexFile = backupFileIfExists(moduleIndexFile, backupModuleIndexFile)

    try {
        def baseFixArgs = [gradleCmd, "fixTestNativeImageRun", "-PtestLibraryCoordinates=${coordinate}", "-PnewLibraryVersion=${newVersion}"]
        List<String> fixArgs = withUnsetTckDir(baseFixArgs)
        def fixLogFile = new File(logsDir, "fixTestNativeImageRun-${fileSuffix}.log")
        int fixExit = project.ext.runLoggedCommand(fixArgs, "fixTestNativeImageRun (${coordinate} -> ${newVersion})", fixLogFile, project.rootDir)
        if (fixExit != 0) {
            throw new GradleException("fixTestNativeImageRun failed with exit code ${fixExit} (see ${fixLogFile})")
        }
    } finally {
        // Revert changes
        restoreDir(hadNewVersionDir, newVersionDir, backupNewMetadataDir)
        restoreDir(hadTestsDir, testsDir, fixBackupTestsDir)
        restoreFileIfBackedUp(hadModuleIndexFile, moduleIndexFile, backupModuleIndexFile)
        // Cleanup backups
        project.delete(fixBackupRoot)
    }
}

private static String sanitizeFileName(String coordinate) {
    coordinate.replaceAll(File.separator, "-").replaceAll(":", "-")
}
