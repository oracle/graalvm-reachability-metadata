/*
 * Copyright and related rights waived via CC0
 *
 * You should have received a copy of the CC0 legalcode along with this
 * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */

plugins {
    id 'org.graalvm.internal.tck-base'
}

import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import org.graalvm.internal.tck.ContributionTask
import org.graalvm.internal.tck.DockerTask
import org.graalvm.internal.tck.ConfigFilesChecker
import org.graalvm.internal.tck.DockerUtils
import org.graalvm.internal.tck.ScaffoldTask
import org.graalvm.internal.tck.GrypeTask
import org.graalvm.internal.tck.TestedVersionUpdaterTask
import org.graalvm.internal.tck.harness.tasks.TestInvocationTask
import org.graalvm.internal.tck.harness.tasks.CheckstyleInvocationTask
import org.graalvm.internal.tck.harness.tasks.CleanInvocationTask
import org.graalvm.internal.tck.harness.tasks.JavacInvocationTask
import org.graalvm.internal.tck.harness.tasks.JavaTestInvocationTask
import org.graalvm.internal.tck.harness.tasks.NativeTestCompileInvocationTask
import org.graalvm.internal.tck.updaters.FetchExistingLibrariesWithNewerVersionsTask
import org.graalvm.internal.tck.updaters.GroupUnsupportedLibraries
import org.gradle.util.internal.VersionNumber
import org.graalvm.internal.tck.PullImagesFromFileTask


import static org.graalvm.internal.tck.Utils.generateTaskName

logger.lifecycle("GraalVM Reachability Metadata TCK")
logger.lifecycle("---------------------------------")

def writeGithubOutput(String key, String value) {
    def path = System.getenv("GITHUB_OUTPUT")
    if (path == null || path.trim().isEmpty()) {
        println "${key}=${value}"
    } else {
        new File(path).append("${key}=${value}\n")
    }
}

String coordinateFilter = Objects.requireNonNullElse(project.findProperty("coordinates"), "")

// Support fractional batching coordinates in the form "k/n" (e.g., "1/16")
static boolean isFractionalBatch(String s) {
    return s != null && (s ==~ /\d+\/\d+/)
}

static List<Integer> parseFraction(String s) {
    def m = s =~ /(\d+)\/(\d+)/
    if (!m.matches()) return null
    int k = (m[0][1] as int)
    int n = (m[0][2] as int)
    return [k, n]
}

static List<String> computeBatchedCoordinates(List<String> coordinates, int index, int batches) {
    if (batches <= 0) throw new GradleException("Invalid batches denominator: ${batches}")
    if (index < 1 || index > batches) throw new GradleException("Invalid batch index: ${index}/${batches}")
    def sorted = new ArrayList<String>(coordinates)
    Collections.sort(sorted)
    int target = (index - 1)
    def result = []
    int i = 0
    for (String c : sorted) {
        if ((i % batches) == target) {
            result.add(c)
        }
        i++
    }
    return result
}

List<String> matchingCoordinates
if (isFractionalBatch(coordinateFilter)) {
    def frac = parseFraction(coordinateFilter)
    List<String> all = tck.getMatchingCoordinates("all")
    matchingCoordinates = computeBatchedCoordinates(all, frac[0], frac[1])
} else {
    matchingCoordinates = tck.getMatchingCoordinates(coordinateFilter)
}

// gradle test -Pcoordinates=<maven-coordinates>
Provider<Task> test = tasks.register("test", DefaultTask) { task ->
    task.setDescription("Tests GraalVM Reflection Metadata that matches given coordinates")
    task.setGroup(JavaBasePlugin.VERIFICATION_GROUP)
}

// gradle checkstyle -Pcoordinates=<maven-coordinates>
Provider<Task> checkstyle = tasks.register("checkstyle") { task ->
    task.setDescription("Runs checkstyle on all subprojects")
    task.setGroup(JavaBasePlugin.VERIFICATION_GROUP)
}

 // gradle javac -Pcoordinates=<maven-coordinates>
Provider<Task> javac = tasks.register("javac") { task ->
    task.setDescription("Compiles sources (javac) for all subprojects")
    task.setGroup(LifecycleBasePlugin.BUILD_GROUP)
}

 // gradle nativeTestCompile -Pcoordinates=<maven-coordinates>
Provider<Task> nativeTestCompile = tasks.register("nativeTestCompile") { task ->
    task.setDescription("Compiles native tests (nativeTestCompile) for all subprojects")
    task.setGroup(LifecycleBasePlugin.BUILD_GROUP)
}

 // gradle javaTest -Pcoordinates=<maven-coordinates>
Provider<Task> javaTest = tasks.register("javaTest") { task ->
    task.setDescription("Runs JVM tests (Gradle 'test') for all subprojects")
    task.setGroup(JavaBasePlugin.VERIFICATION_GROUP)
}

tasks.named("check").configure {
    dependsOn(checkstyle)
}

final String METADATA_GROUP = "Metadata"




// Here we want to configure all test and checkstyle tasks for all filtered subprojects
for (String coordinates in matchingCoordinates) {
    String testTaskName = generateTaskName("test", coordinates)
    if ((!tasks.getNames().contains(testTaskName))) {
        tasks.register(testTaskName, TestInvocationTask, coordinates)
    }
    test.configure {
        dependsOn(testTaskName)
    }

    String checkstyleTaskName = generateTaskName("checkstyle", coordinates)
    if ((!tasks.getNames().contains(checkstyleTaskName))) {
        tasks.register(checkstyleTaskName, CheckstyleInvocationTask, coordinates)
    }
    checkstyle.configure {
        dependsOn(checkstyleTaskName)
    }

    String cleanTaskName = generateTaskName("clean", coordinates)
    if ((!tasks.getNames().contains(cleanTaskName))) {
        tasks.register(cleanTaskName, CleanInvocationTask, coordinates)
    }
    clean.configure {
        dependsOn(cleanTaskName)
    }

    String javacTaskName = generateTaskName("javac", coordinates)
    if ((!tasks.getNames().contains(javacTaskName))) {
        tasks.register(javacTaskName, JavacInvocationTask, coordinates)
    }
    javac.configure {
        dependsOn(javacTaskName)
    }

    String nativeTestCompileTaskName = generateTaskName("nativeTestCompile", coordinates)
    if ((!tasks.getNames().contains(nativeTestCompileTaskName))) {
        tasks.register(nativeTestCompileTaskName, NativeTestCompileInvocationTask, coordinates)
    }
    nativeTestCompile.configure {
        dependsOn(nativeTestCompileTaskName)
    }

    String javaTestTaskName = generateTaskName("javaTest", coordinates)
    if ((!tasks.getNames().contains(javaTestTaskName))) {
        tasks.register(javaTestTaskName, JavaTestInvocationTask, coordinates)
    }
    javaTest.configure {
        dependsOn(javaTestTaskName)
    }

    String pullDockerTaskName = generateTaskName("pullAllowedDockerImages", coordinates)
    if ((!tasks.getNames().contains(pullDockerTaskName))) {
        tasks.register(pullDockerTaskName, DockerTask.class) { t ->
            t.setCoordinates(coordinates)
        }
    }
}

// gradle diff -PbaseCommit=<base-commit> -PnewCommit=<new-commit>
Provider<Task> diff = tasks.register("diff", DefaultTask) { task ->
    task.setDescription("Tests GraalVM Reflection Metadata that was changed between 'baseCommit' and 'newCommit'")
    task.setGroup(JavaBasePlugin.VERIFICATION_GROUP)

    if (!project.hasProperty("baseCommit")) {
        task.doFirst {
            throw new GradleException("Missing 'baseCommit' property! Rerun Gradle with '-PbaseCommit=<commit-hash>'")
        }
    }
}

List<String> diffCoordinates = new ArrayList<>()
if (project.hasProperty("baseCommit")) {
    String baseCommit = project.findProperty("baseCommit")
    String newCommit = Objects.requireNonNullElse(project.findProperty("newCommit"), "HEAD")
    for (def coordinates in tck.diffCoordinates(baseCommit, newCommit)) {
        diffCoordinates.add(coordinates)
        String taskTaskName = generateTaskName("test", coordinates)
        if ((!tasks.getNames().contains(taskTaskName))) {
            tasks.register(taskTaskName, TestInvocationTask, coordinates)
        }
        diff.configure {
            dependsOn(taskTaskName)
        }
    }
}

Map<String, Object> loadCi() {
    File f = project.file("ci.json")
    if (!f.exists()) {
        throw new GradleException("Missing ci.json in repo root")
    }
    new JsonSlurper().parse(f) as Map<String, Object>
}

Map<String, List<String>> matrixDefaultsFor(String section) {
    def ci = loadCi()
    def sec = ci[section]
    if (sec == null) throw new GradleException("Missing '${section}' in ci.json")
    [
        "version": (sec["java"] as List<String>),
        "os": (sec["os"] as List<String>)
    ]
}

// gradle generateMatrixMatchingCoordinates -Pcoordinates=<maven-coordinates>
Provider<Task> generateMatrixMatchingCoordinates = tasks.register("generateMatrixMatchingCoordinates", DefaultTask) { task ->
    task.setDescription("Returns matrix definition populated with all matching coordinates")
    task.setGroup(METADATA_GROUP)
    task.doFirst {
        def matrix = [
                "coordinates": matchingCoordinates
        ]
        matrix.putAll(matrixDefaultsFor("generateMatrixMatchingCoordinates"))
        writeGithubOutput("matrix", JsonOutput.toJson(matrix))
    }
}

 // gradle generateMatrixBatchedCoordinates [-Pbatches=<n>]
Provider<Task> generateMatrixBatchedCoordinates = tasks.register("generateMatrixBatchedCoordinates", DefaultTask) { task ->
    task.setDescription("Returns matrix definition populated with fractional batch coordinates (k/n)")
    task.setGroup(METADATA_GROUP)
    task.doFirst {
        int batches = project.hasProperty("batches") ? Integer.parseInt(project.findProperty("batches").toString()) : 16
        if (batches <= 0) {
            throw new GradleException("Invalid 'batches' value: ${batches}")
        }
        List<String> coords = (1..batches).collect { i -> "${i}/${batches}" }
        def matrix = [
                "coordinates": coords
        ]
        matrix.putAll(matrixDefaultsFor("generateMatrixBatchedCoordinates"))
        writeGithubOutput("matrix", JsonOutput.toJson(matrix))
    }
}

// gradle generateChangedCoordinatesMatrix -PbaseCommit=<base-commit> -PnewCommit=<new-commit>
Provider<Task> generateChangedCoordinatesMatrix = tasks.register("generateChangedCoordinatesMatrix", DefaultTask) { task ->
    task.setDescription("Returns matrix definition populated with coordinates of changed libraries")
    task.setGroup(METADATA_GROUP)
    task.doFirst {
        if (!project.hasProperty("baseCommit")) {
            throw new GradleException("Missing 'baseCommit' property! Rerun Gradle with '-PbaseCommit=<commit-hash>'")
        }

        boolean noneFound = diffCoordinates.isEmpty()
        def matrix = [
                "coordinates": noneFound ? [] : diffCoordinates
        ]
        matrix.putAll(matrixDefaultsFor("generateChangedCoordinatesMatrix"))
        if (noneFound) {
            println "No changed coordinates were found!"
        }


        writeGithubOutput("matrix", JsonOutput.toJson(matrix))
        writeGithubOutput("none-found", noneFound.toString())
    }
}

// gradle generateInfrastructureChangedCoordinatesMatrix -PbaseCommit=<base-commit> -PnewCommit=<new-commit>
Provider<Task> generateInfrastructureChangedCoordinatesMatrix = tasks.register("generateInfrastructureChangedCoordinatesMatrix", DefaultTask) { task ->
    task.setDescription("Returns matrix definition populated with pre-selected coordinates when test infrastructure has changed")
    task.setGroup(METADATA_GROUP)
    task.doFirst {
        List<String> selected = []
        boolean infraChanged = true
        // Pre-selected modules; keep stable for infra verification
        List<String> preselectedModules = [
                'ch.qos.logback:logback-classic',
                'org.bouncycastle:bcpkix-jdk18on',
                'io.netty:netty-common',
                'io.grpc:grpc-core',
                'org.postgresql:postgresql',
                'org.apache.kafka:kafka-clients',
                'com.zaxxer:HikariCP',
                'org.hibernate.validator:hibernate-validator',
                'io.undertow:undertow-core',
                'com.hazelcast:hazelcast'
        ]
        preselectedModules.each { module ->
            List<String> matches = tck.getMatchingCoordinates(module)
            if (!matches.isEmpty()) {
                def withVersions = matches.collect { c ->
                    def v = c.substring(c.lastIndexOf(':') + 1)
                    [coord: c, ver: v]
                }
                def latest = withVersions.max { a, b -> VersionNumber.parse(a.ver) <=> VersionNumber.parse(b.ver) }
                selected.add(latest.coord)
            } else {
                throw new GradleException("No tested versions found for ${module}, skipping")
            }
        }

        def matrix = [
            "coordinates": selected
        ]
        matrix.putAll(matrixDefaultsFor("generateInfrastructureChangedCoordinatesMatrix"))


        writeGithubOutput("matrix", JsonOutput.toJson(matrix))
        writeGithubOutput("none-found", "false")
    }
}

// new library version updaters tasks
tasks.register("fetchExistingLibrariesWithNewerVersions", FetchExistingLibrariesWithNewerVersionsTask.class) { task ->
    task.setGroup(METADATA_GROUP)
    task.setDescription("Returns list of all libraries coordinates")
    task.setAllLibraryCoordinates(matchingCoordinates)
}

tasks.register("groupLibrariesByName", GroupUnsupportedLibraries.class) { task ->
    task.setGroup(METADATA_GROUP)
    task.setDescription("Extracts groups of libraries from github comments provided in a form of string.")
}


tasks.register("addTestedVersion", TestedVersionUpdaterTask.class) { task ->
    task.setDescription("Updates list of tested versions.")
    task.setGroup(METADATA_GROUP)
}

// docker tasks
tasks.register("checkAllowedDockerImages", GrypeTask.class) { task ->
    task.setDescription("Returns list of allowed docker images")
    task.setGroup(METADATA_GROUP)
}

def imagesFileProvider = project.layout.buildDirectory.file("tck/required-docker-images.txt")

def computeImages = tasks.register("computeAllowedDockerImagesFile", DefaultTask) { task ->
    task.setDescription("Computes allowed docker images required by matching coordinates and writes them to a file")
    task.setGroup(METADATA_GROUP)
    task.outputs.file(imagesFileProvider)
    task.doFirst {
        if (matchingCoordinates == null || matchingCoordinates.isEmpty()) {
            throw new GradleException("No matching coordinates found for property 'coordinates'. Provide -Pcoordinates=<filter> or a fractional batch 'k/n'.")
        }
        Set<String> unionRequired = new LinkedHashSet<>()
        matchingCoordinates.each { c ->
            def parts = c.split(":")
            if (parts.length < 3) {
                logger.warn("Skipping invalid coordinates: ${c}")
                return
            }
            def group = parts[0]
            def artifact = parts[1]
            def version = parts[2]
            File f = project.file("tests/src/${group}/${artifact}/${version}/required-docker-images.txt")
            if (f.exists()) {
                f.readLines()
                        .collect { it?.trim() }
                        .findAll { it && !it.startsWith("#") }
                        .each { unionRequired.add(it) }
            }
        }

        Set<String> allowed = DockerUtils.getAllAllowedImages()
        def notAllowed = unionRequired.findAll { !allowed.contains(it) }
        if (!notAllowed.isEmpty()) {
            throw new GradleException("The following images are not in the allowed list: ${notAllowed}. " +
                    "If you need them, add Dockerfiles under tests/tck-build-logic/src/main/resources/allowed-docker-images " +
                    "per CONTRIBUTING.md, or adjust required-docker-images.txt files.")
        }

        def finalList = unionRequired.findAll { allowed.contains(it) }.toList()
        println "Collected ${finalList.size()} required allowed image(s)"
        File outFile = imagesFileProvider.get().asFile
        outFile.parentFile.mkdirs()
        outFile.text = finalList.join(System.lineSeparator())
    }
}

tasks.register("pullAllowedDockerImages", PullImagesFromFileTask.class) { task ->
    task.setDescription("Pull allowed docker images required by matching coordinates")
    task.setGroup(METADATA_GROUP)
    task.getImagesFile().set(imagesFileProvider)
}.configure { t ->
    t.dependsOn(computeImages)
}


// contributing tasks
tasks.register("scaffold", ScaffoldTask.class) { task ->
    task.setDescription("Creates a metadata and test scaffold for the given coordindates")
    task.setGroup(METADATA_GROUP)
    // Format JSON after task has been run
    task.finalizedBy("spotlessApply")
}

tasks.register("contribute", ContributionTask.class) { task ->
    task.setDescription("Generates metadata and prepares pull request for contibuting on metadata repository based on provided tests.")
    task.setGroup(METADATA_GROUP)
}

tasks.register("checkConfigFiles", ConfigFilesChecker.class) { task ->
    task.setDescription("Checks content of config files for a new library.")
    task.setGroup(METADATA_GROUP)
}
