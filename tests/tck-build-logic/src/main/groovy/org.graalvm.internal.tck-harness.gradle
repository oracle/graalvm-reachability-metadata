/*
 * Copyright and related rights waived via CC0
 *
 * You should have received a copy of the CC0 legalcode along with this
 * work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
 */
plugins {
    id 'org.graalvm.internal.tck-base'
}

import groovy.json.JsonOutput
import groovy.json.JsonSlurper
import org.graalvm.internal.tck.ContributionTask
import org.graalvm.internal.tck.DockerTask
import org.graalvm.internal.tck.MetadataFilesCheckerTask
import org.graalvm.internal.tck.DockerUtils
import org.graalvm.internal.tck.ScaffoldTask
import org.graalvm.internal.tck.FixTestNativeImageRun
import org.graalvm.internal.tck.GrypeTask
import org.graalvm.internal.tck.GenerateMetadataTask
import org.graalvm.internal.tck.TestedVersionUpdaterTask
import org.graalvm.internal.tck.harness.tasks.TestInvocationTask
import org.graalvm.internal.tck.harness.tasks.CheckstyleInvocationTask
import org.graalvm.internal.tck.harness.tasks.CleanInvocationTask
import org.graalvm.internal.tck.harness.tasks.CompileTestJavaInvocationTask
import org.graalvm.internal.tck.harness.tasks.JavaTestInvocationTask
import org.graalvm.internal.tck.harness.tasks.NativeTestCompileInvocationTask
import org.graalvm.internal.tck.harness.tasks.FetchExistingLibrariesWithNewerVersionsTask
import org.gradle.util.internal.VersionNumber
import org.graalvm.internal.tck.harness.tasks.ComputeAndPullAllowedDockerImagesTask
import org.graalvm.internal.tck.harness.tasks.CheckMetadataFilesAllTask
import org.graalvm.internal.tck.harness.tasks.ValidateIndexFilesTask
import org.graalvm.internal.tck.utils.CoordinateUtils
import org.graalvm.internal.tck.utils.MetadataGenerationUtils


import static org.graalvm.internal.tck.Utils.generateTaskName

logger.lifecycle("GraalVM Reachability Metadata TCK")
logger.lifecycle("---------------------------------")

final String METADATA_GROUP = "Metadata"

def writeGithubOutput(String key, String value) {
    def path = System.getenv("GITHUB_OUTPUT")
    if (path == null || path.trim().isEmpty()) {
        println "${key}=${value}"
    } else {
        new File(path).append("${key}=${value}\n")
    }
}

def writeGithubEnv(String key, String value) {
    def path = System.getenv("GITHUB_ENV")
    if (path == null || path.trim().isEmpty()) {
        println "${key}=${value}"
    } else {
        new File(path).append("${key}=${value}\n")
    }
}

String coordinateFilter = Objects.requireNonNullElse(project.findProperty("coordinates"), "")


List<String> matchingCoordinates
if (CoordinateUtils.isFractionalBatch(coordinateFilter)) {
    def frac = CoordinateUtils.parseFraction(coordinateFilter)
    List<String> all = tck.getMatchingCoordinates("all")
    matchingCoordinates = CoordinateUtils.computeBatchedCoordinates(all, frac[0], frac[1])
} else {
    matchingCoordinates = tck.getMatchingCoordinates(coordinateFilter)
}
matchingCoordinates = matchingCoordinates.findAll { !it.startsWith("samples:") }


// gradle checkstyle -Pcoordinates=<maven-coordinates>
tasks.register("checkstyle", CheckstyleInvocationTask.class) { task ->
    task.setDescription("Runs checkstyle on all subprojects")
    task.setGroup(JavaBasePlugin.VERIFICATION_GROUP)
}

// gradle compileTestJava -Pcoordinates=<maven-coordinates>
tasks.register("compileTestJava", CompileTestJavaInvocationTask.class) { task ->
    task.setDescription("Compiles sources (javac) for all subprojects")
    task.setGroup(LifecycleBasePlugin.BUILD_GROUP)
}

// gradle javaTest -Pcoordinates=<maven-coordinates>
tasks.register("javaTest", JavaTestInvocationTask.class) { task ->
    task.setDescription("Runs JVM tests (Gradle 'test') for all subprojects")
    task.setGroup(JavaBasePlugin.VERIFICATION_GROUP)
}

// gradle nativeTestCompile -Pcoordinates=<maven-coordinates>
tasks.register("nativeTestCompile", NativeTestCompileInvocationTask.class) { task ->
    task.setDescription("Compiles native tests (nativeTestCompile) for all subprojects")
    task.setGroup(LifecycleBasePlugin.BUILD_GROUP)
}

// gradle clean -Pcoordinates=<maven-coordinates>
if (tasks.findByName("clean") == null) {
    tasks.register("clean", CleanInvocationTask.class) { t ->
        t.setDescription("Cleans all matching subprojects")
        t.setGroup(LifecycleBasePlugin.BUILD_GROUP)
    }
} else {
    tasks.register("tckClean", CleanInvocationTask.class) { t ->
        t.setDescription("Cleans all matching subprojects (TCK)")
        t.setGroup(LifecycleBasePlugin.BUILD_GROUP)
    }
    tasks.named("clean").configure { it.dependsOn("tckClean") }
}

// gradle test -Pcoordinates=<maven-coordinates>
if (tasks.findByName("test") == null) {
    tasks.register("test", TestInvocationTask.class) { t ->
        t.setDescription("Runs Native Image tests for all matching coordinates")
        t.setGroup(JavaBasePlugin.VERIFICATION_GROUP)
    }
} else {
    tasks.register("tckTest", TestInvocationTask.class) { t ->
        t.setDescription("Runs Native Image tests for all matching coordinates (TCK)")
        t.setGroup(JavaBasePlugin.VERIFICATION_GROUP)
    }
    tasks.named("test").configure { it.dependsOn("tckTest") }
}

tasks.register("validateIndexFiles", ValidateIndexFilesTask.class) { task ->
    task.setDescription("Checks content of index.json files for matching coordinates or files")
    task.setGroup(JavaBasePlugin.VERIFICATION_GROUP)
}

// gradle checkMetadataFiles -Pcoordinates=<maven-coordinates>
tasks.register("checkMetadataFiles", CheckMetadataFilesAllTask.class) { task ->
    task.setDescription("Checks content of metadata files for matching coordinates")
    task.setGroup(METADATA_GROUP)
}

tasks.named("check").configure {
    dependsOn("checkstyle")
}

// gradle diff -PbaseCommit=<base-commit> -PnewCommit=<new-commit>
Provider<Task> diff = tasks.register("diff", DefaultTask) { task ->
    task.setDescription("Tests GraalVM Reflection Metadata that was changed between 'baseCommit' and 'newCommit'")
    task.setGroup(JavaBasePlugin.VERIFICATION_GROUP)

    if (!project.hasProperty("baseCommit")) {
        task.doFirst {
            throw new GradleException("Missing 'baseCommit' property! Rerun Gradle with '-PbaseCommit=<commit-hash>'")
        }
    }
}

List<String> diffCoordinates = new ArrayList<>()
if (project.hasProperty("baseCommit")) {
    String baseCommit = project.findProperty("baseCommit")
    String newCommit = Objects.requireNonNullElse(project.findProperty("newCommit"), "HEAD")
    diffCoordinates.addAll(tck.diffCoordinates(baseCommit, newCommit))
    tasks.register("testDiff", TestInvocationTask.class) { t ->
        t.setCoordinatesOverride(diffCoordinates)
    }
    diff.configure {
        dependsOn("testDiff")
    }
}

Map<String, Object> loadCi() {
    File f = project.file("ci.json")
    if (!f.exists()) {
        throw new GradleException("Missing ci.json in repo root")
    }
    new JsonSlurper().parse(f) as Map<String, Object>
}

Map<String, List<String>> matrixDefaultsFor(String section) {
    def ci = loadCi()
    def sec = ci[section]
    if (sec == null) throw new GradleException("Missing '${section}' in ci.json")
    [
            "version": (sec["java"] as List<String>),
            "os": (sec["os"] as List<String>)
    ]
}

Map<String, Object> springAotMatrixConfig() {
    def ci = loadCi()
    def sec = ci["generateAffectedSpringTestMatrix"]
    if (sec == null) throw new GradleException("Missing 'generateAffectedSpringTestMatrix' in ci.json")
    [
            "java-branch-mapping": (sec["java-branch-mapping"] as Map<String, String>),
            "os": sec["os"]
    ]
}

// gradle generateMatrixMatchingCoordinates -Pcoordinates=<maven-coordinates>
Provider<Task> generateMatrixMatchingCoordinates = tasks.register("generateMatrixMatchingCoordinates", DefaultTask) { task ->
    task.setDescription("Returns matrix definition populated with all matching coordinates")
    task.setGroup(METADATA_GROUP)
    task.doFirst {
        def matrix = [
                "coordinates": matchingCoordinates
        ]
        matrix.putAll(matrixDefaultsFor("generateMatrixMatchingCoordinates"))
        writeGithubOutput("matrix", JsonOutput.toJson(matrix))
    }
}

// gradle generateMatrixBatchedCoordinates [-Pbatches=<n>]
Provider<Task> generateMatrixBatchedCoordinates = tasks.register("generateMatrixBatchedCoordinates", DefaultTask) { task ->
    task.setDescription("Returns matrix definition populated with fractional batch coordinates (k/n)")
    task.setGroup(METADATA_GROUP)
    task.doFirst {
        int batches = project.hasProperty("batches") ? Integer.parseInt(project.findProperty("batches").toString()) : 16
        if (batches <= 0) {
            throw new GradleException("Invalid 'batches' value: ${batches}")
        }
        List<String> coords = (1..batches).collect { i -> "${i}/${batches}" }
        def matrix = [
                "coordinates": coords
        ]
        matrix.putAll(matrixDefaultsFor("generateMatrixBatchedCoordinates"))
        writeGithubOutput("matrix", JsonOutput.toJson(matrix))
    }
}

// gradle generateChangedCoordinatesMatrix -PbaseCommit=<base-commit> -PnewCommit=<new-commit>
Provider<Task> generateChangedCoordinatesMatrix = tasks.register("generateChangedCoordinatesMatrix", DefaultTask) { task ->
    task.setDescription("Returns matrix definition populated with coordinates of changed libraries")
    task.setGroup(METADATA_GROUP)
    task.doFirst {
        if (!project.hasProperty("baseCommit")) {
            throw new GradleException("Missing 'baseCommit' property! Rerun Gradle with '-PbaseCommit=<commit-hash>'")
        }

        boolean noneFound = diffCoordinates.isEmpty()
        def matrix = [
                "coordinates": noneFound ? [] : diffCoordinates
        ]
        matrix.putAll(matrixDefaultsFor("generateChangedCoordinatesMatrix"))
        if (noneFound) {
            println "No changed coordinates were found!"
        }


        writeGithubOutput("matrix", JsonOutput.toJson(matrix))
        writeGithubOutput("none-found", noneFound.toString())
    }
}

// gradle generateChangedIndexFileCoordinatesList -PbaseCommit=<base-commit> -PnewCommit=<new-commit>
tasks.register("generateChangedIndexFileCoordinatesList", DefaultTask) { task ->
    task.setDescription("Returns a list of changed coordinates for validation based on git diff")
    task.setGroup(METADATA_GROUP)

    task.doLast {
        if (!project.hasProperty("baseCommit")) {
            throw new GradleException("Missing 'baseCommit' property! Rerun Gradle with '-PbaseCommit=<commit-hash>'")
        }

        String base = project.property("baseCommit")
        String head = project.findProperty("newCommit") ?: "HEAD"

        List<String> changedIndexFileCoordinates = tck.diffIndexCoordinates(base, head)

        boolean noneFound = changedIndexFileCoordinates.isEmpty()

        if (noneFound) {
            println "No changed index.json files were found!"
        }

        writeGithubOutput("changed-coordinates", changedIndexFileCoordinates.join(' '))
        writeGithubOutput("none-found", noneFound.toString())
    }
}

// gradle generateInfrastructureChangedCoordinatesMatrix -PbaseCommit=<base-commit> -PnewCommit=<new-commit>
Provider<Task> generateInfrastructureChangedCoordinatesMatrix = tasks.register("generateInfrastructureChangedCoordinatesMatrix", DefaultTask) { task ->
    task.setDescription("Returns matrix definition populated with pre-selected coordinates when test infrastructure has changed")
    task.setGroup(METADATA_GROUP)
    task.doFirst {
        List<String> selected = []
        boolean infraChanged = true
        // Pre-selected modules; keep stable for infra verification
        List<String> preselectedCoordinates = [
                'ch.qos.logback:logback-classic',
                'org.bouncycastle:bcpkix-jdk18on',
                'io.netty:netty-common',
                'io.grpc:grpc-core',
                'org.postgresql:postgresql',
                'org.apache.kafka:kafka-clients',
                'com.zaxxer:HikariCP',
                'org.hibernate.validator:hibernate-validator',
                'io.undertow:undertow-core',
                'com.hazelcast:hazelcast'
        ]
        preselectedCoordinates.each { module ->
            List<String> matches = tck.getMatchingCoordinates(module)
            if (!matches.isEmpty()) {
                def withVersions = matches.collect { c ->
                    def v = c.substring(c.lastIndexOf(':') + 1)
                    [coord: c, ver: v]
                }
                def latest = withVersions.max { a, b -> VersionNumber.parse(a.ver) <=> VersionNumber.parse(b.ver) }
                selected.add(latest.coord)
            } else {
                throw new GradleException("No tested versions found for ${module}, skipping")
            }
        }

        def matrix = [
                "coordinates": selected
        ]
        matrix.putAll(matrixDefaultsFor("generateInfrastructureChangedCoordinatesMatrix"))


        writeGithubOutput("matrix", JsonOutput.toJson(matrix))
        writeGithubOutput("none-found", "false")
    }
}

// new library version updaters tasks
tasks.register("fetchExistingLibrariesWithNewerVersions", FetchExistingLibrariesWithNewerVersionsTask.class) { task ->
    task.setGroup(METADATA_GROUP)
    task.setDescription("Returns list of all libraries coordinates")
    task.setAllLibraryCoordinates(matchingCoordinates)
}

tasks.register("addTestedVersion", TestedVersionUpdaterTask.class) { task ->
    task.setDescription("Updates list of tested versions.")
    task.setGroup(METADATA_GROUP)
}

// docker tasks
tasks.register("checkAllowedDockerImages", GrypeTask.class) { task ->
    task.setDescription("Returns list of allowed docker images")
    task.setGroup(METADATA_GROUP)
}

tasks.register("pullAllowedDockerImages", ComputeAndPullAllowedDockerImagesTask.class) { task ->
    task.setDescription("Computes and pulls allowed docker images required by matching coordinates")
    task.setGroup(METADATA_GROUP)
}

// contributing tasks
tasks.register("scaffold", ScaffoldTask.class) { task ->
    task.setDescription("Creates a metadata and test scaffold for the given coordindates")
    task.setGroup(METADATA_GROUP)
    // Format JSON after task has been run
    task.finalizedBy("spotlessApply")
}

tasks.register("contribute", ContributionTask.class) { task ->
    task.setDescription("Generates metadata and prepares pull request for contibuting on metadata repository based on provided tests.")
    task.setGroup(METADATA_GROUP)
}

// gradle generateMetadata -Pcoordinates=<maven-coordinates> [or --coordinates=<maven-coordinates>] --agentAllowedPackages=<comma-separated list of packages>
tasks.register("generateMetadata", GenerateMetadataTask.class) { task ->
    task.setDescription("Generates metadata based on provided tests.")
    task.setGroup(METADATA_GROUP)
}

// gradle fixTestNIRun -PtestLibraryCoordinates=<maven-coordinates> -PnewLibraryVersion=<library version which needs fix>
tasks.register("fixTestNativeImageRun", FixTestNativeImageRun.class) { task ->
    task.setDescription("Fix test that fails Native Image run for new library version.")
    task.setGroup(METADATA_GROUP)
}

// gradle addLibraryAsLatestMetadataIndexJson -Pcoordinates=<maven-coordinates> [-PtestVersion=<version>]
tasks.register("addLibraryAsLatestMetadataIndexJson", DefaultTask) { task ->
    task.setDescription("Marks given coordinates as latest in metadata/group/artifact/index.json")
    task.setGroup(METADATA_GROUP)
    task.doFirst {
        if (!project.hasProperty("coordinates")) {
            throw new GradleException("Missing 'coordinates' property! Rerun Gradle with -Pcoordinates=<group:artifact:version>")
        }
        def coordsStr = project.findProperty("coordinates").toString()
        def coords = CoordinateUtils.fromString(coordsStr)
        def testVersion = project.hasProperty("testVersion") ? project.findProperty("testVersion").toString() : null
        MetadataGenerationUtils.makeVersionLatestInIndexJson(project.layout, coords, testVersion)
    }
}

// gradle extractLibraryTestParams -Pcoordinates=<group:artifact[:version]>
tasks.register("extractLibraryTestParams", DefaultTask) { task ->
    task.setDescription("Extracts TEST_PATH, LATEST_VERSION and TEST_COORDINATES for given coordinates (group:artifact[:version]). Writes them into GITHUB_ENV.")
    task.setGroup(METADATA_GROUP)
    task.doFirst {
        if (!project.hasProperty("coordinates")) {
            throw new GradleException("Missing 'coordinates' property! Rerun Gradle with -Pcoordinates=<group:artifact[:version]>")
        }
        def coordsStr = project.findProperty("coordinates").toString()
        def parts = coordsStr.split(":")
        if (parts.length < 2) {
            throw new GradleException("Invalid 'coordinates' value; expected group:artifact or group:artifact:version, got: ${coordsStr}")
        }
        String lib = parts[0] + ":" + parts[1]

        String libPath = lib.replace(":", "/")
        File indexFile = project.file("metadata/${libPath}/index.json")

        Map latestEntry = null
        if (indexFile.exists()) {
            def entries = new JsonSlurper().parse(indexFile) as List<Map>
            latestEntry = entries.find { e -> Boolean.TRUE.equals(e["latest"]) }
            if (latestEntry == null && !entries.isEmpty()) {
                latestEntry = entries.max { e -> VersionNumber.parse((e["metadata-version"] ?: "").toString()) }
            }
        }

        String latestVersion = null
        String testVersionFolder = null

        if (latestEntry != null) {
            latestVersion = (latestEntry["metadata-version"] ?: "").toString()
            def tv = latestEntry["test-version"]
            testVersionFolder = (tv != null && tv.toString().trim()) ? tv.toString() : latestVersion
        } else {
            if (!indexFile.exists()) {
                throw new GradleException("Missing index.json at ${indexFile}. Cannot determine latest metadata version.")
            }
            def entries = new JsonSlurper().parse(indexFile) as List<Map>
            if (entries.isEmpty()) {
                throw new GradleException("Empty index.json at ${indexFile}.")
            }
            latestVersion = entries.collect { it["metadata-version"].toString() }
                    .max { v -> VersionNumber.parse(v) }
        }

        if (testVersionFolder == null || testVersionFolder.trim().isEmpty()) {
            File testsLibDir = project.file("tests/src/${libPath}")
            if (!testsLibDir.exists()) {
                throw new GradleException("No tests directory found for ${lib} at ${testsLibDir}")
            }
            File[] dirs = testsLibDir.listFiles()
            List<File> versionDirs = dirs == null ? [] : dirs.findAll { it.isDirectory() }
            if (versionDirs.isEmpty()) {
                throw new GradleException("No version subdirectories found in ${testsLibDir}")
            }
            testVersionFolder = versionDirs.max { d -> VersionNumber.parse(d.name) }.name
        }

        String testPath = "${libPath}/${testVersionFolder}"
        String testCoordinates = testPath.replace("/", ":")

        writeGithubEnv("LATEST_VERSION", latestVersion)
        writeGithubEnv("TEST_PATH", testPath)
        writeGithubEnv("TEST_COORDINATES", testCoordinates)
    }
}

// gradle generateAffectedSpringTestMatrix -PbaseCommit=<base> -PnewCommit=<head> -PspringAotBranch=<branch> -PspringAotPath=/path/to/spring-aot-smoke-tests
//
// Generates a GitHub Actions matrix for 'spring-aot-smoke-tests' impacted by metadata changes:
// 1. Identifies changed Group:Artifacts via git diff between commits.
// 2. Runs an impact scan on the spring-aot-smoke-tests repo to find projects transitively depending on those GAs.
// 3. Resolves the Java version for each project, favoring build.gradle overrides over ci.json defaults.
// 4. Emits a JSON matrix to trigger parallel test execution in GitHub Actions.
tasks.register("generateAffectedSpringTestMatrix") { task ->
    task.setDescription("Computes GA changes from git diff, scans Spring AOT for impacted tests, and emits a ready-to-use GitHub Actions matrix.")
    task.setGroup(METADATA_GROUP)

    doLast {
        if (!project.hasProperty("baseCommit")) {
            throw new GradleException("Missing 'baseCommit' property! Rerun Gradle with -PbaseCommit=<commit-hash>")
        }
        if (!project.hasProperty("springAotBranch")) {
            throw new GradleException("Missing 'springAotBranch' property! Rerun Gradle with -PspringAotBranch=<branch>")
        }
        if (!project.hasProperty("springAotPath")) {
            throw new GradleException("Missing 'springAotPath' property! Rerun Gradle with -PspringAotPath=<spring-aot-smoke-tests-path>")
        }

        // Resolve Spring AOT dir
        def springDir = project.file(project.findProperty("springAotPath").toString())
        if (!springDir.exists()) {
            throw new GradleException("Spring AOT path does not exist: ${springDir.absolutePath}")
        }

        // Resolve default Java and OS for this branch from ci.json
        def springAotCfg = springAotMatrixConfig()
        def javaBranchMapping = (springAotCfg["java-branch-mapping"] as Map<String, String>)
        def branch = project.findProperty("springAotBranch").toString()
        String defaultJavaStr = javaBranchMapping.get(branch)
        if (defaultJavaStr == null || defaultJavaStr.trim().isEmpty()) {
            throw new GradleException("Unknown springAotBranch '${branch}' in ci.json mapping")
        }
        Integer defaultJava = Integer.parseInt(defaultJavaStr)

        // Compute versionless GA targets from diffCoordinates
        boolean noneFound = diffCoordinates.isEmpty()
        List<String> versionless = []
        if (!noneFound) {
            versionless = diffCoordinates.collect { c ->
                def parts = c.split(":", 3)
                "${parts[0]}:${parts[1]}"
            }.unique()
            noneFound = versionless.isEmpty()
        }

        if (noneFound) {
            writeGithubOutput("impacted_tests", "")
            writeGithubOutput("matrix", JsonOutput.toJson([include: []]))
            writeGithubOutput("none-found", "true")
            return
        }

        // Init script within this repo (corrected path)
        File initScript = project.file("tests/tck-build-logic/scripts/spring-aot-impact-scan.gradle")
        if (!initScript.exists()) {
            throw new GradleException("Missing init script: ${initScript.absolutePath}")
        }

        // Execute impact scan in Spring AOT repo
        ByteArrayOutputStream stdout = new ByteArrayOutputStream()
        def execOps = project.services.get(ExecOperations)
        execOps.exec {
            workingDir = springDir
            executable = "${springDir.absolutePath}/gradlew"
            args = [
                    "-I", initScript.absolutePath,
                    "-PimpactCoordinatesList=${versionless.join(',')}",
                    "__internalImpactScan",
                    "-q",
                    "--no-daemon",
                    "--console=plain",
                    "--warning-mode=none"
            ]
            standardOutput = stdout
            errorOutput = stdout
            ignoreExitValue = true
        }

        // Parse impact results
        List<String> results = stdout.toString().split("\n")
                .findAll { it.startsWith("IMPACT_MATCH:") }
                .collect { it.replace("IMPACT_MATCH:", "") }
                .unique()

        // Write impacted tests (CSV)
        writeGithubOutput("impacted_tests", results.join(','))

        boolean noneFoundTests = results.isEmpty()

        // Build matrix with per-project Java override detection
        List<Map<String, String>> include = []
        results.each { String p ->
            String relPath = p.replaceFirst("^:", "").replace(":", "/")
            File gradleFile = new File(springDir, "${relPath}/build.gradle")

            Integer currentJava = defaultJava
            if (gradleFile.isFile()) {
                try {
                    String text = gradleFile.getText("UTF-8")
                    def m = (text =~ /(?m)^\s*(?:.*?\.)?javaVersion\s*=\s*['"](\d+)['"]/)
                    if (m.find()) {
                        Integer override = Integer.parseInt(m.group(1))
                        if (override > currentJava) {
                            currentJava = override
                        }
                    }
                } catch (Exception ignore) {
                    // ignore parse errors, fall back to defaultJava
                }
            }

            include.add([project: p, java: currentJava.toString(), os: "ubuntu-latest"])
        }

        writeGithubOutput("matrix", JsonOutput.toJson([include: include]))
        writeGithubOutput("none-found", noneFoundTests.toString())
    }
}
